//Run Time: 192ms - 11.66%
//Memory Usage: 70.4MB - 17.02%
//Solved =)
//n = num nodes
//i = initial
//Time O(max(n^2, i^2)) Memory O(n^2)

class Solution {
public:
    int dfs(vector<vector<int>>& adjList, vector<bool>& visited, int node) {
        if(visited[node]) return 0;
        visited[node] = true;
        int numCells = 1;
        for(int i = 0; i < adjList[node].size(); ++i) {
            numCells += dfs(adjList, visited, adjList[node][i]);
        }
        return numCells;
    } 
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        //Removed node has to have maximum influence
        //n = 300 nodes
        //O(n^2)
        //do dfs for each node except the 
        //make adjList
        vector<vector<int>> adjList(graph.size(), vector<int>());
        for(int i = 0; i < graph.size(); ++i) {
            for(int j = 0; j < graph[i].size(); ++j) {
                if(graph[i][j] == 0) continue;
                adjList[i].push_back(j);
            }
        }

        int greatestIndex = initial[0], minInfection = INT_MAX;
        sort(initial.begin(), initial.end());
        for(int i = 0; i < initial.size(); ++i) {
            int curInfection = 0;
            vector<bool> visited(graph.size(), false);
            for(int j = 0; j < initial.size(); ++j) {
                //skip if the nodes are the same
                if(i == j) continue;
                curInfection += dfs(adjList, visited, initial[j]);
            }
            //cout << initial[i] << " -> " << curInfection << endl;
            if(curInfection < minInfection) {
                minInfection = curInfection;
                greatestIndex = initial[i];
            }
        }
        return greatestIndex;
    }
};

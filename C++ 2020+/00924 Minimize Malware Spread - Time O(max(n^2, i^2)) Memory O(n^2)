//Run Time: 140ms - 68.12%
//Memory Usage: 70.4MB - 67.92%
//Solved =)
//n = num nodes
//i = initial
//Time O(max(n^2, i^2)) Memory O(n^2)

class DisjointSet {
    vector<int> nodes;
    vector<int> groupSize;
public:
    DisjointSet(int size) {
        nodes = vector<int>(size, 0);
        groupSize = vector<int>(size, 1);
        for(int i = 0; i < size; ++i) {
            nodes[i] = i;
        }
    }

    int getRoot(int node) {
        int root = node;
        while(nodes[root] != root) root = nodes[root];
        //path compression
        while(nodes[node] != node) {
            int prevNode = node;
            node = nodes[node];
            nodes[prevNode] = root;
            groupSize[prevNode] = groupSize[root];
        }
        return root;
    }

    void unite(int node1, int node2) {
        int root1 = getRoot(node1);
        int root2 = getRoot(node2);
        if(root1 == root2) return;
        nodes[root2] = nodes[root1];
        groupSize[root2] += groupSize[root1];
        groupSize[root1] = groupSize[root2];
    }

    int getGroupSize(int node) { return groupSize[node]; }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        //Disjoint Set
        DisjointSet disjointSet((int)graph.size());
        for(int i = 0; i < graph.size(); ++i) {
            for(int j = i+1; j < graph[i].size(); ++j) {
                if(graph[i][j] == 0) continue;
                disjointSet.unite(i, j);
            }
        }

        int greatestIndex = initial[0], minInfection = INT_MAX;
        for(int i = 0; i < initial.size(); ++i) {
            int curInfection = 0;
            vector<bool> seenRoots(graph.size(), false);
            for(int j = 0; j < initial.size(); ++j) {
                //skip if the nodes are the same
                if(i == j) continue;
                int curRoot = disjointSet.getRoot(initial[j]);
                if(seenRoots[curRoot]) continue;
                seenRoots[curRoot] = true;
                curInfection += disjointSet.getGroupSize(curRoot);
            }
            //cout << initial[i] << " -> " << curInfection << endl;
            if(curInfection <= minInfection) {
                if(minInfection == curInfection) greatestIndex = min(greatestIndex, initial[i]); 
                else greatestIndex = initial[i];
                minInfection = curInfection;
            }
        }
        return greatestIndex;
    }
};
